REM BBP pi calculation like youtu.be/SPTzzSuBFlc
:
REM todo convert bignum operators to byte-by-byte
:
REM in distant future the two bignums are opposite
REM endianness because they can then share memory
:
REM using four divisions for small denominators
REM the numerator is a bignum
REM the denominator is probably two bytes
:
REM the temporary T is a bignum
REM but as all we do is shift a two byte window
REM it probably shouldn't be
:
REM we're proceeding like this
REM   S=0:N=4:K=0
REM   FOR digit=0 TO 19
REM     S=S+N/(K+1)
REM     S=S-N/(2*(K+4))
REM     S=S-N/(4*(K+5))
REM     S=S-N/(4*(K+6))
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K=K+8
REM   NEXT
:
T=TIME: @%=&2090C: REM MODE 0
:
REM bignums are a list of bytes - just 4 at present
REM one byte, the first byte, is the integer part
:
Scale=2^24 : REM the scaled unit, 1.0, a global
REM byte-aligning U might be simplest
:
big=4
DIM SumP big : REM our bignum series accumulator
DIM NumeratorP big : REM bignum numerator
DIM TempP big : REM temporary bignum for division
:
REM our numerator is rescaled by 10/16 each digit
PROCset(NumeratorP, 1)
:
REM the denominator is a (two byte?) integer
REM and K is the iteration variable
K%=1
:
REM start producing digits!
PROCset(SumP, 0)
REPEAT
:
REM compute N/K and add/sub the quotient into S
REM we adjust the denominator as needed

PROCdivaddsub(NumeratorP, 4, K%, SumP, 1)
K%=K%+3
PROCdivaddsub(NumeratorP, 2, K%, SumP, -1)
K%=K%+1
PROCdivaddsub(NumeratorP, 1, K%, SumP, -1)
K%=K%+1
PROCdivaddsub(NumeratorP, 1, K%, SumP, -1)
K%=K%+3
:
REM S is updated, now take a digit
:
G%=FNextract(SumP)
PRINT !SumP/Scale" "CHR$(48+G%)
:
PROCmask(SumP) : REM remove that digit from S
PROCx10(SumP)
:
REM now re-scale the numerator
PROCrescale(NumeratorP)
:
UNTIL K%>72 : REM about 8 good digits from 8bit basic
:
PRINT (TIME-T) DIV 100"s"
END
:
REM --------------------------------------------------
:
DEF PROCset(BignumP, C)
REM C is a tiny integer - one byte
REM integer end of our bignum is at the far end
FOR I%=0 TO big-1
  BignumP?I%=0
NEXT
BignumP?(big-1)=C
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCcopy(TempP, NumeratorP)
REM used once, could be inlined
FOR I%=0 TO big-1
  TempP?I%=NumeratorP?I%
NEXT
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCdivaddsub(NumeratorP, prescale, K%, SumP, add)
REM NumeratorP is a bignum
REM prescale is a 1, 2 or 4 multiplier
REM K% is an int (presently is pre-scaled)
REM SumP is a bignum
REM add is 1 for addition and -1 for subtraction
:
REM example worked division
REM &3D0900 / &24 = &1B207
REM &12 too small (15 bits shift)
REM &24 still smaller (16 bits shift)
REM &48 too big (so backtrack)
:
REM T is a bignum temporary to be reduced to zero
REM which we might be able to do without
PROCcopy(TempP, NumeratorP)
REM scaling is just a shift which we can finesse
:
REM probably good to keep track of top non-zero byte
REM we'd like to line up rapidly at the start of play
:
REM we will need to shift the denominator
REM but that's not destructive really
REM just a sliding three byte(?) window
D%=K% : REM using a temporary for convenience
:
REM align the denominator for the subtraction
REM I is the bit we're going to set, or add in
REM I is an LSB marker, lines up with LSB of D
REM pre-scale accounts for different numerators
I%=prescale
:
REPEAT I%=I%*2:D%=D%*2:UNTIL D%>!TempP
:
REM backtrack because we overdid it by one shift
I%=I% DIV 2: D%=D% DIV 2 : REM just shifts
:
REM division by repeated shift and subtract
REM accumulating each bit into our sum as we go
REM sum is a bignum but carries will be limited
REM so we'll propagate only as many as needed
REM better to accumulate a byte of bits and add
REM them all at once
:
REM here D moves to the right getting smaller
REM but maybe moving the bits of T left might win
REM we'd fill in leftmost byte from N
REM every 8 shifts
:
REPEAT
IF !TempP>=D% THEN !TempP=!TempP-D%: !SumP=!SumP+add*I%
I%=I% DIV 2: D%=D% DIV 2
UNTIL I%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCrescale(NumeratorP)
!NumeratorP=10*(!NumeratorP DIV 16)
ENDPROC
:
REM --------------------------------------------------
:
DEF FNextract(SumP)
REM a sanity check is that this is 9 at most
=!SumP DIV Scale     : REM decimal digit, just a shift
:
REM --------------------------------------------------
:
DEF PROCmask(SumP)
REM set integer part of the bignum to zero
I%=big-1
SumP?I%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCx10(SumP)
  REM bignum multiply by small number
  REM two byte result needs to be carried
  LOCAL carry, temp
  carry=0
  FOR I%=0 TO big-1
    temp=(SumP?I%)*10 + carry
    SumP?I% = temp AND 255
    carry = temp DIV 256
  NEXT
ENDPROC

ENDPROC
:
REM --------------------------------------------------
:
DEF PROCdebug(NumeratorP,K%)
REM for debug, show the N and D
at%=@%
@%=&90A:PRINT !NumeratorP/Scale,K%,;
@%=at%
ENDPROC
