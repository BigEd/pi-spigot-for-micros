REM BBP pi calculation like youtu.be/SPTzzSuBFlc
:
REM todo convert bignum operators to byte-by-byte
:
REM in distant future the two bignums are opposite
REM endianness because they can then share memory
:
REM using four divisions for small denominators
REM the numerator is a bignum
REM the denominator is probably two bytes
:
REM the temporary T is a bignum
REM but as all we do is shift a two byte window
REM it probably shouldn't be
:
REM we're proceeding like this
REM   S=0:N=4:K=0
REM   FOR digit=0 TO 19
REM     S=S+N/(K+1)
REM     S=S-N/(2*(K+4))
REM     S=S-N/(4*(K+5))
REM     S=S-N/(4*(K+6))
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K=K+8
REM   NEXT
:
REM equivalently and possibly preferable
REM   S=0:N=4
REM   K1=1
REM   K2=8
REM   K3=20
REM   K4=24
REM   FOR digit=0 TO 19
REM     S=S+N/K1
REM     S=S-N/K2
REM     S=S-N/K3
REM     S=S-N/K4
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K1=K1+8
REM     K2=K2+16
REM     K3=K3+32
REM     K4=K4+32
REM   NEXT
:
REM equivalently and possibly preferable
REM   S=0:N=4
REM   K=0
REM   FOR digit=0 TO 19
REM     T=K+1
REM     S=S+N/T
REM     T=T+K+7
REM     S=S-N/T
REM     T=T+2*K+12
REM     S=S-N/T
REM     T=T+4
REM     S=S-N/T
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K=K+8
REM   NEXT
:
t0=TIME: @%=&2090C: REM MODE 0
:
REM bignums are a list of bytes - just 4 at present
REM one byte, the first byte, is the integer part
:
Scale=2^24 : REM the scaled unit, 1.0, a global
REM byte-aligning U might be simplest
:
big=4
DIM SumP big : REM our bignum series accumulator
DIM NumeratorP big : REM bignum numerator
DIM TempP big : REM temporary bignum for division
:
REM our numerator will be rescaled by 10/16 each digit
PROCset(NumeratorP, 4)
:
REM the denominator is a (two or three byte) integer
REM and K is the iteration variable
K%=0
:
REM start producing digits!
PROCset(SumP, 0)
REPEAT
:
REM compute N/K and add/sub the quotient into S
REM we adjust the denominator as needed
T=K%+1
PROCdivaddsub(NumeratorP, T, SumP, 1)
T=T+K%+7
PROCdivaddsub(NumeratorP, T, SumP, -1)
T=T+2*K%+12
PROCdivaddsub(NumeratorP, T, SumP, -1)
T=T+4
PROCdivaddsub(NumeratorP, T, SumP, -1)
K%=K%+8
:
REM S is updated, now take a digit
:
G%=FNextract(SumP)
PRINT !SumP/Scale" "CHR$(48+G%)
:
PROCmask(SumP) : REM remove that digit from S
PROCx10(SumP)
:
REM now re-scale the numerator
PROCrescale(NumeratorP)
:
UNTIL K%>72 : REM about 8 good digits from 8bit basic
:
PRINT (TIME-t0) DIV 100"s"
END
:
REM --------------------------------------------------
:
DEF PROCset(BignumP, C)
REM C is a tiny integer - one byte
REM integer end of our bignum is at the far end
FOR I%=0 TO big-1
  BignumP?I%=0
NEXT
BignumP?(big-1)=C
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCcopy(TempP, NumeratorP)
REM used once, could be inlined
FOR I%=0 TO big-1
  TempP?I%=NumeratorP?I%
NEXT
ENDPROC
:
REM --------------------------------------------------
:
REM notes on division
REM ideally we use no bignum temporaries
REM but presently we use two
REM 
REM TempP is a bignum temporary to be reduced to zero
REM which we might be able to do without
:
REM maybe good to keep track of top non-zero byte
REM of the denominator
REM we'd like to line up rapidly at the start of play
REM expect that's just a small constant piece of work
:
REM we will need to shift the denominator
REM but that's not destructive really
REM just a sliding three byte(?) window
REM using a temporary D% for convenience
:
REM We align the denominator for the subtraction
REM I is the bit we're going to set, or add in
REM I is an LSB marker, lines up with LSB of D
REM we over shift and then unshift to correct
:
REM division by repeated shift and subtract
REM accumulating each bit into our sum as we go
REM sum is a bignum but carries will be limited
REM so we'll propagate only as many as needed
REM better to accumulate a byte of bits and add
REM them all at once
:
REM here D moves to the right getting smaller
REM but maybe moving the bits of T left might win
REM we'd fill in leftmost byte from N
REM every 8 shifts
:
REM NumeratorP is a bignum
REM K% is an integer, the number to divide by
REM SumP is a bignum to add or subtract into
REM add is 1 for addition and -1 for subtraction
:
REM --------------------------------------------------
:
DEF PROCdivaddsub(NumeratorP, K%, SumP, add)
:
PROCcopy(TempP, NumeratorP)
D%=K%
:
I%=1
REPEAT I%=I%*2:D%=D%*2:UNTIL D%>!TempP
I%=I% DIV 2: D%=D% DIV 2
:
REPEAT
  IF !TempP >= D% THEN !TempP=!TempP-D%: !SumP=!SumP+add*I%
  I%=I% DIV 2
  D%=D% DIV 2
  UNTIL I%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCrescale(BignumP)
REM we multiply by 10/16 which is less than one
REM possibly could shortcut this
REM but taking a brute force approach for now
PROCx10(BignumP)
LOCAL carry, temp
carry=0
FOR I%=big-1 TO 0 STEP -1
  temp=BignumP?I%
  BignumP?I% = (BignumP?I%) DIV 16 + (carry * 16)
  carry = temp AND 15
NEXT
ENDPROC
:
REM --------------------------------------------------
:
DEF FNextract(BignumP)
REM a sanity check is that this is 9 at most
=(BignumP?(big-1)) : REM decimal digit, just the top byte
:
REM --------------------------------------------------
:
DEF PROCmask(SumP)
REM set integer part of the bignum to zero
I%=big-1
SumP?I%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCx10(BignumP)
  REM bignum multiply by small number
  REM two byte result from each digit demands a carry
  LOCAL carry, temp
  carry=0
  FOR I%=0 TO big-1
    temp=(BignumP?I%)*10 + carry
    BignumP?I% = temp AND 255
    carry = temp DIV 256
  NEXT
ENDPROC
