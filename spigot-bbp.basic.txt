REM BBP pi calculation like youtu.be/SPTzzSuBFlc
:
REM todo convert bignum operators to byte-by-byte
REM todo need byte-by-byte shifts not bit-by-bit in division
REM todo need a byte pointer into the middle of the bignum
REM todo the initial alignment of divisor can be simple
REM need a 'small' variable to count the size of K
:
REM in distant future the two bignums are opposite
REM endianness because they can then share memory
:
REM using four divisions for small denominators
REM the numerator is a bignum
REM the denominator is probably two bytes
:
REM the temporary T is a bignum
REM but as all we do is shift a two byte window
REM it probably shouldn't be
:
REM we're proceeding like this
REM   S=0:N=4:K=0
REM   FOR digit=0 TO 19
REM     S=S+N/(K+1)
REM     S=S-N/(2*(K+4))
REM     S=S-N/(4*(K+5))
REM     S=S-N/(4*(K+6))
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K=K+8
REM   NEXT
:
REM equivalently and possibly preferable
REM   S=0:N=4
REM   K1=1
REM   K2=8
REM   K3=20
REM   K4=24
REM   FOR digit=0 TO 19
REM     S=S+N/K1
REM     S=S-N/K2
REM     S=S-N/K3
REM     S=S-N/K4
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K1=K1+8
REM     K2=K2+16
REM     K3=K3+32
REM     K4=K4+32
REM   NEXT
:
REM equivalently and possibly preferable
REM   S=0:N=4
REM   K=0
REM   FOR digit=0 TO 19
REM     T=K+1
REM     S=S+N/T
REM     T=T+K+7
REM     S=S-N/T
REM     T=T+2*K+12
REM     S=S-N/T
REM     T=T+4
REM     S=S-N/T
REM     PRINT digit," ";S;" digit ";INTS
REM     S=S-INTS
REM     S=S*10
REM     N=N*10/16
REM     K=K+8
REM   NEXT
:
t0=TIME: REM MODE 0
:
REM bignums are a list of bytes - just 4 at present
REM one byte, the first byte, is the integer part
:
digits=8
big=((digits*5) DIV 12)+1
PRINT "Digits = ";digits
PRINT "   Big = ";big;" bytes"
:
REM pad bignums to ensure 4-byte comparison at the end to see zeros
pad=4
:
DIM SumP       big + pad: REM our bignum series accumulator
DIM NumeratorP big + pad: REM bignum numerator
DIM TempP      big + pad: REM temporary bignum for division
:
REM our numerator will be rescaled by 10/16 each digit
PROCset(NumeratorP, 4)
:
REM the denominator is a (two or three byte) integer
REM and K is the iteration variable
K%=0
:
REM start producing digits!
PROCset(SumP, 0)
REPEAT
:
REM compute N/K and add/sub the quotient into S
REM we adjust the denominator as needed
T=K%+1
PROCdivaddsub(NumeratorP, T, SumP, "add")
T=T+K%+7
PROCdivaddsub(NumeratorP, T, SumP, "sub")
T=T+2*K%+12
PROCdivaddsub(NumeratorP, T, SumP, "sub")
T=T+4
PROCdivaddsub(NumeratorP, T, SumP, "sub")
K%=K%+8
:
REM S is updated, now take a digit
:
PRINT CHR$(48+FNextract(SumP));
:
PROCmask(SumP) : REM remove that digit from S
PROCx10(SumP)
:
REM now re-scale the numerator
PROCrescale(NumeratorP)
:
UNTIL K%>=8*digits : REM about 8 good digits from 8bit basic
:
PRINT '(TIME-t0) DIV 100"s"
END
:
REM --------------------------------------------------
:
DEF PROCset(BignumP, C)
REM C is a tiny integer - one byte
REM integer end of our bignum is at the far end
FOR I%=0 TO big-1
  BignumP?I%=0
NEXT
BignumP?(big-1)=C
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCcopy(TempP, NumeratorP)
REM used once, could be inlined
FOR I%=0 TO big-1
  TempP?I%=NumeratorP?I%
NEXT
ENDPROC
:
REM --------------------------------------------------
:
REM notes on division
REM ideally we use no bignum temporaries
REM but presently we use two
REM
REM TempP is a bignum temporary to be reduced to zero
REM which we might be able to do without
:
REM maybe good to keep track of top non-zero byte
REM of the denominator
REM we'd like to line up rapidly at the start of play
REM expect that's just a small constant piece of work
:
REM we will need to shift the denominator
REM but that's not destructive really
REM just a sliding three byte(?) window
REM using a temporary D% for convenience
:
REM We align the denominator for the subtraction
REM I is the bit we're going to set, or add in
REM I is an LSB marker, lines up with LSB of D
REM we over shift and then unshift to correct
:
REM division by repeated shift and subtract
REM accumulating each bit into our sum as we go
REM sum is a bignum but carries will be limited
REM so we'll propagate only as many as needed
REM better to accumulate a byte of bits and add
REM them all at once
:
REM here D moves to the right getting smaller
REM but maybe moving the bits of T left might win
REM we'd fill in leftmost byte from N
REM every 8 shifts
:
REM NumeratorP is a bignum
REM K% is an integer, the number to divide by
REM SumP is a bignum to add or subtract into
REM op$ is "add" or "sub"
:
REM --------------------------------------------------
:
DEF PROCdivaddsub(NumeratorP, K%, SumP, op$)
:
PROCcopy(TempP, NumeratorP)
D%=K% : REM presently D in fact doesn't change
:
S%=0: REM S for shift (an exponent)
REPEAT S%=S%+1:UNTIL NOT FNcmp(TempP,D%,S%)
S%=S%-1
IF S%>=8*big:PRINT "S too large"; S%:STOP
:
REPEAT
  cmp=FNcmp(TempP,D%,S%)
  IF cmp THEN IF op$="add" PROCadd(SumP, 1, S%)
  IF cmp THEN IF op$="sub" PROCsub(SumP, 1, S%)
  IF cmp THEN PROCsub(TempP, D%, S%)
  S%=S%-1
UNTIL S%<0
:
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCadd(BignumP, N%, S%)
  LOCAL I%,carry,temp
  N%=N%*2^(S% MOD 8)
  I%=S% DIV 8
  carry=0
  REPEAT
    temp=BignumP?I% + (N% AND 255) + carry
    BignumP?I% = temp AND 255
    carry = temp DIV 256
    N%=N% DIV 256
    I%=I%+1
  UNTIL I%=big OR (N%=0 AND carry=0)
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCsub(BignumP, N%, S%)
  LOCAL I%,carry,temp
  N%=N%*2^(S% MOD 8)
  I%=S% DIV 8
  carry=0
  REPEAT
    temp=512 + BignumP?I% - (N% AND 255) - carry
    BignumP?I% = temp AND 255
    carry = (temp DIV 256) AND 1
    N%=N% DIV 256
    I%=I%+1
  UNTIL I%=big OR (N%=0 AND carry=0)
ENDPROC
:
REM --------------------------------------------------
:
REM compare bignum with integer presuming some alignment
REM returns TRUE if bignum>=N%<<S%
DEF FNcmp(BignumP, N%, S%)
  LOCAL I%,J%
  N%=N%*2^(S% MOD 8)
  I%=S% DIV 8
  REM work out MSB of bignum
  J%=big
  REPEAT
    J%=J%-1
  UNTIL J%<0 OR BignumP?J%>0
  REM Case 1: bignum has non-zero elements beyond N, so must be > N%
  IF J%>=I%+4 =TRUE
  REM Case 2: bignum=0 so return answer based on N% only
  IF J%<0 =(N%=0)
  REM Case 3: return result based on a comparison
=(BignumP!I%>=N%)
:
REM --------------------------------------------------
:
DEF PROCrescale(BignumP)
REM we multiply by 10/16 which is less than one
REM possibly could shortcut this
REM but taking a brute force approach for now
PROCx10(BignumP)
LOCAL carry, temp
carry=0
FOR I%=big-1 TO 0 STEP -1
  temp=BignumP?I%
  BignumP?I% = (BignumP?I%) DIV 16 + (carry * 16)
  carry = temp AND 15
NEXT
ENDPROC
:
REM --------------------------------------------------
:
DEF FNextract(BignumP)
REM a sanity check is that this is 9 at most
REM assumes bignum has 1 byte before the binary point
=(BignumP?(big-1)) : REM decimal digit, just the top byte
:
REM --------------------------------------------------
:
DEF PROCmask(SumP)
REM set integer part of the bignum to zero
REM assumes bignum has 1 byte before the binary point
I%=big-1
SumP?I%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCx10(BignumP)
  REM bignum multiply by small number
  REM two byte result from each digit demands a carry
  LOCAL carry, temp
  carry=0
  FOR I%=0 TO big-1
    temp=(BignumP?I%)*10 + carry
    BignumP?I% = temp AND 255
    carry = temp DIV 256
  NEXT
ENDPROC
