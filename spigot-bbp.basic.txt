REM BBP pi calculation like youtu.be/SPTzzSuBFlc
:
REM pi to 80 digits is
REM 31415926535897932384
REM 62643383279502884197
REM 16939937510582097494
REM 45923078164062862089
:
t0=TIME
:
REM bignums are a list of bytes, LSB first (lowest address)
REM one byte, the first byte, is the integer part
:
digits=8
big=((digits*5) DIV 12)+1 : REM can add 1 or 2 for guard digits
PRINT "Digits = ";digits
PRINT "   Big = ";big;" bytes"
:
REM pad bignums to ensure 4-byte comparison at the end to see zeros
pad=4
:
DIM SumP       big + pad: REM our bignum series accumulator
DIM NumeratorP big + pad: REM bignum numerator
DIM TempP      big + pad: REM temporary bignum for division
:
base=0 : A%=base : REM our bignums can get shorter as we go
:
REM our numerator will be rescaled by 10/16 each digit
PROCset(NumeratorP, 4)
:
REM the denominator is a (two or three byte) integer
REM and K is the iteration variable
K%=0
:
REM start producing digits!
PROCset(SumP, 4)
first=TRUE
REPEAT
:
REM compute N/K and add/sub the quotient into S
REM we adjust the denominator as needed
T=K%+1
IF NOT first PROCdivaddsub(NumeratorP, T, SumP, "add")
first=FALSE
T=T+K%+7
PROCdivaddsub(NumeratorP, T, SumP, "sub")
T=T+2*K%+12
PROCdivaddsub(NumeratorP, T, SumP, "sub")
T=T+4
PROCdivaddsub(NumeratorP, T, SumP, "sub")
K%=K%+8
:
REM S is updated, now take a digit
:
PRINT CHR$(48+FNextract(SumP));
:
PROCmask(SumP) : REM remove that digit from S
PROCx10(SumP)
:
REM now re-scale the numerator
PROCrescale(NumeratorP)
:
IF K%>24 base=base+106/256:A%=base
UNTIL K%>=8*digits
:
PRINT '(TIME-t0) DIV 100"s"
END
:
REM --------------------------------------------------
:
DEF PROCset(BignumP, C)
REM C is a tiny integer - one byte
REM integer end of our bignum is at the far end
FOR I%=A% TO big-1
  BignumP?I%=0
NEXT
BignumP?(big-1)=C
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCcopy(TempP, NumeratorP)
REM used once, could be inlined
FOR I%=A% TO big-1
  TempP?I%=NumeratorP?I%
NEXT
ENDPROC
:
REM --------------------------------------------------
:
REM NumeratorP is a bignum
REM K% is an integer, the number to divide by
REM SumP is a bignum to add or subtract into
REM op$ is "add" or "sub"
:
REM --------------------------------------------------
:
DEF PROCdivaddsub(NumeratorP, K%, SumP, op$)
:
LOCAL S%,T%
PROCcopy(TempP, NumeratorP)
D%=K% : REM presently D in fact doesn't change
:
FOR T%=big-2 TO A% STEP -1
  byte%=0
  FOR S%=8*T%+7 TO 8*T% STEP -1
    byte%=byte%*2
    IF FNcmp(TempP,D%,S%) PROCsubbit(TempP, D%, S%):byte%=byte%+1
  NEXT
  IF byte%<>0: IF op$="add" PROCaddbyte(SumP, byte%, T%)
  IF byte%<>0: IF op$="sub" PROCsubbyte(SumP, byte%, T%)
NEXT
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCaddbyte(BignumP, N%, I%)
  LOCAL temp
  REPEAT
    temp=BignumP?I% + N%
    BignumP?I% = temp AND 255
    IF (temp AND 256) N%=1 ELSE N%=0
    I%=I%+1
  UNTIL I%=big OR N%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCsubbyte(BignumP, N%, I%)
  LOCAL temp
  REPEAT
    temp=BignumP?I% - N%
    BignumP?I% = temp AND 255
    IF (temp AND 256) N%=1 ELSE N%=0
    I%=I%+1
  UNTIL I%=big OR N%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCsubbit(BignumP, N%, S%)
  LOCAL I%,carry,temp
  N%=N%*2^(S% MOD 8)
  I%=S% DIV 8
  carry=0
  REPEAT
    temp=512 + BignumP?I% - (N% AND 255) - carry
    BignumP?I% = temp AND 255
    carry = (temp DIV 256) AND 1
    N%=N% DIV 256
    I%=I%+1
  UNTIL I%=big OR (N%=0 AND carry=0)
ENDPROC
:
REM --------------------------------------------------
:
REM compare bignum with integer presuming some alignment
REM returns TRUE if bignum>=N%<<S%
DEF FNcmp(BignumP, N%, S%)
  LOCAL I%,J%
  N%=N%*2^(S% MOD 8)
  I%=S% DIV 8
  REM work out MSB of bignum
  J%=big
  REPEAT
    J%=J%-1
  UNTIL J%<0 OR BignumP?J%>0
  REM Case 1: bignum has non-zero elements beyond N, so must be > N%
  IF J%>=I%+4 =TRUE
  REM Case 2: bignum=0 so return answer based on N% only
  IF J%<0 =(N%=0)
  REM Case 3: return result based on a comparison
  IF BignumP!I%<0: =TRUE
=(BignumP!I%>=N%)
:
REM --------------------------------------------------
:
DEF PROCrescale(BignumP)
REM we multiply by 10/16 which is less than one
PROCx10(BignumP)
LOCAL carry, temp
carry=0
FOR I%=big-1 TO A% STEP -1
  temp=BignumP?I%
  BignumP?I% = (BignumP?I%) DIV 16 + (carry * 16)
  carry = temp AND 15
NEXT
ENDPROC
:
REM --------------------------------------------------
:
DEF FNextract(BignumP)
REM a sanity check is that this is 9 at most
REM assumes bignum has 1 byte before the binary point
=(BignumP?(big-1)) : REM decimal digit, just the top byte
:
REM --------------------------------------------------
:
DEF PROCmask(SumP)
REM set integer part of the bignum to zero
REM assumes bignum has 1 byte before the binary point
I%=big-1
SumP?I%=0
ENDPROC
:
REM --------------------------------------------------
:
DEF PROCx10(BignumP)
  REM bignum multiply by small number
  REM two byte result from each digit demands a carry
  LOCAL carry, temp
  carry=0
  FOR I%=A% TO big-1
    temp=(BignumP?I%)*10 + carry
    BignumP?I% = temp AND 255
    carry = temp DIV 256
  NEXT
ENDPROC
